              __                   _      __           __           
             |  \ _  _  _  _ |/   (_     (_ . _  _ | _(_  _ _. _ |_ 
             |__/(_|| )|||(_||\|_|| |_|  __)|||||_)|(-__)(_| ||_)|_ 
                                               |             |     
               * Danmakufu Simplescript (DSS) Documentation (Version XX)
               * Updated XX

Intro: 
Danmakufu Simplescript is a "second look" at the idea of customized 
Touhou levels. It is different from Danmakufu's Language, to the point that an 
automated converter is probably impossible to create. SimpleScript (DSS) is not 
a programming language, in that it is not possible to control the "Game Engine" 
into producing behaviors it could not already do. Rather, DSS is made to be run 
on top of an engine that offers a full suite of features, and the script needs 
merely select which ones to "engage." Expert users may find this idea 
restrictive. For those having this preconception, I encourage you to actually 
dive in to the quick tutorials below. DSS is essentially XML script, in a 
condensed format. By condensed, I really mean that each node of the data Tree 
(if you aren't familiar with text based trees, check out a quick book on XML 
format) corresponds 99% of the time to an entity that will actually appear, on 
screen, in your level. Nodes of the tree can be of one of a few predetermined 
classes, but may be arbitrarily nested. The nesting of nodes (heiarchical 
relationships) is significant, and the possible nesting effects will become 
clear in the explanation below. Finally, if this document serves to frustrate or 
overwhelm you in detail, just remember that I intend users to learn DSS by trial 
and error, by copy and paste, and by putting thoughts to paper. Not by reading 
the docs. ENJOY 

Claim: 
For every dream you can have, DSS will enable you to put it into action 
before the end of the universe. 

Definition of a Syntax Parser: 
A machine which reads in your DSS, and interprets how 
it's going to run your touhou level. It will yell at you if you give it slop, 
and will try to help you fix problems. Using the editor, you will be able to see 
the feedback the parser gives you, and hopefully correctly interpret what the 
syntax parser is telling you. All in all, there must be 2 way communication 
between you and the parser in order for the coding to go smoothly. 

Structure of a DSS script: 
A DSS Script is a tree of nodes. The function of a 
node at play-time is determined by 3 factors: 1) The location of the node. - 
Many nodes will be "Top Level". That is, they will not be nested inside any 
other node. 

Structure of a Node: 
A Node has key value pairs, or nested nodes. 
SYNTAX:
<class> <name> 
     <key> = <value>
     <key> = <value>
\ <value, wrapping to second line>
\ <and so on.>
}
__ END SYNTAX    
Where the '<>' mean "insert your word here". All punctuation needed is shown above.
Line returns are significant, and required. The facing left curly brace ends the node it matches to
on the stack. A facing right curly brace is not necessary to begin a node, but is common.
See "Comments" to discover that comments can go anywhere.

Nested nodes are created in the same syntax as a normal node, placed inside of the curly braces.

Structure of a Key Value Pair:
Keys are case sensitive, and must be one of the parameters specified at the end of this 
guide. Values are, well, rather unbounded in form.

Comments on Comments:
The parser's view on comments, is that any text which does not resemble a syntactic
structure is a comment. If the text being parsed resembles a syntactic structure,
but is not parsable, then the parser yells at you. Thus, there is a fine line between
text that looks like it may be parsable, but contains errors, and text that is meant
to be comments. 99% of the time, if you just write reasonable comments, it will recognize
them as such and not parse them in. The other 1% of the time, add a # character at the beginning
of the line, so it REALLY knows it's a comment. I've never had to do this, yet.

Saved DSS files:
DSS script is text based, so one could theoretically copy the code (the in game editor
supports copy and paste, so you know) and email it to a friend on the Usenet. However,
I was lieing if I implied that a touhou level can be represented entirely in text. Of
course there are graphics and many other lovely things! Thus, there is a format which
should be used to distribute DSS scripts which will have no file extension. This format
consists of garbled characters, which encodes for both the DSS script and any other
metadata that the editor generates and are necessary for your level. You may try to 
decrypt this format, be my guest. However, the most important detail is that this 
format is predetermined (as of may 2009) , and will NEVER BE CHANGED. To see an example
of why more than just the text script is needed, see the Graphics sections below.

Graphics:
I have a personal annoyance with scripts that make you do things like this:
FlandreAnimation = 
     [Flandre.gif[100,100,50,50,@HORIZ_FLIP], 20, 
      Flandre.gif[130,100,50,50,@HORIZ_FLIP], 20,
      Flandre.gif[160,100,50,50,@HORIZ_FLIP], 20 ]
just to represent a sprite. Writing the pixel locations by hand like this is 
prone to error making, and when you're adding 50+ sprites to a level, this gets
old really fast. DSS handles this problem by adding Visual Metadata to some classes
of nodes. Specifically, for nodes that represent an entity on the screen (most of them),
the editor provides a button which can be used to 
  1) Select which image you would like to use (Can be a whole "tilemap", and can be shared)
  2) Drag a rectangle around individual animation frames 
     - Before you freak out, you CAN set the grid resolution, so that you get the tiles
       perfectly 16x16 or whatever you have designed. I know the mouse is not perfect.

As described above, visual metadata such as this (the file paths, and the animation frames)
are contained (along with everything else) in the hashed format which you are given when you press "save".

Addressing Nodes:
In the exceedingly rare case that you need to address one of the nodes in the script
tree absolutely (some of the more advanced features require this), then the address
of any node can be formed by taking a path from the root node to the node, and appending
the names of the nodes on this path with '.' delimiters.

For instance, if "a" held "b" which held "c", the address of "c" would be a.b.c
(period, end of sentence)

Addresses of nodes are non case sensitive.

Now for the rest of the documentation, which is technical, and will be autowritten by the computer.
============================================================================

